<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" type="text/css" href="estilo.css" media="screen" />
  <link href="https://fonts.googleapis.com/css?family=Asap:400i|Gloria+Hallelujah" rel="stylesheet">
  <title>Document</title>
</head>
<body>

  <div class="padre">
  <div class="hijo">
    <h4>Values & Types</h4>
    As we asserted in Chapter 1, JavaScript has typed values, not typed
    variables. The following built-in types are available:
    • string
    • number
    • boolean
    • null and undefined
    • object
    • symbol (new to ES6)
    JavaScript provides a typeof operator that can examine a value and
    tell you what type it is:
    <pre>
      var a;
      typeof a; <a href="">  // "undefined"</a>
      a = "hello world";
      typeof a; <a href="">  //"string"</a>
      a = 42;
      typeof a; <a href="">  // "number"</a>
      a = true;
      typeof a; <a href="">  // "boolean"</a>
      a = null;
      typeof a; <a href="">  // "object"--weird, bug</a>
      a = undefined;
      typeof a; <a href="">  // "undefined"</a>
    </pre>
    <script>

    </script>

  </div>
  </div>


  <div class="padre">
  <div class="hijo">
    <h4>Funciones Basicas 0</h4>
    <pre>
      var nombre; <a>//Variable</a>
      nombre = prompt("ingresa tu nombre"); <a href="">//Abre pantalla emergente preguntando nombre</a>
      alert(nombre); <a href="">//Alerta</a>
      document.write(nombre); <a href="">//Escribe el nombre</a>
      console.log(nombre); <a href="">//Escribe en el terminal</a>
  </pre>
    <script>
      /*
      var nombre;
      nombre = prompt("Ingresa Nombre");
      alert(nombre);
      document.write(nombre);
      */
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Compound Assigment</h4>
    <pre>
      +=, -=, *=, and /=
      are compound operators that combine a math operation with assignment,
      as in a += 2 (same as a = a + 2).
   </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Coercion</h4>
    If you have a number but need to print it on the screen, you need to convert the value to a string, and in
    JavaScript this conversion is called “coercion.”
    <pre>
      var a = "42";
      var b = Number( a );
      console.log( a );   <a href="">// "42"</a>
      console.log( b );   <a href="">// 42 </a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Variables Basicas</h4>
    JavaScript uses the latter approach, dynamic typing, meaning variables
    can hold values of any type without any type enforcement.
    As mentioned earlier, we declare a variable using the var statement
    —notice there’s no other type information in the declaration. Consider
    this simple program:
    <pre>
      var amount = 99.99;
      amount = amount * 2;
      console.log( amount );  <a href="">// 199.98</a>
      <a href="">// convert `amount` to a string, and</a>
      <a href="">// add "$" on the beginning</a>
      amount = "$" + String( amount );
      console.log( amount ); <a href="">// "$199.98"</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Variables Basicas</h4>
    This is more typically called constants, when you declare a variable
    with a value and intend for that value to not change throughout the
    program.
    You declare these constants, often at the top of a program, so that it’s
    convenient for you to have one place to go to alter a value if you
    need to. By convention, JavaScript variables as constants are usually
    capitalized, with underscores _ between multiple words.
    <pre>
      var TAX_RATE = 0.08; <a href="">// 8% sales tax</a>
      var amount = 99.99;
      amount = amount * 2;
      amount = amount + (amount * TAX_RATE);
      console.log( amount ); <a href="">// 215.9784</a>
      console.log( amount.toFixed( 2 ) ); <a href="">// "215.98"</a>
      <a href="">
        Similar to how console.log(..) is a function log(..) accessed as an object property on the
        console value, toFixed(..) here is a function that can be accessed on number values.
        JavaScript numbers aren’t automatically formatted for dollars—
        the engine doesn’t know what your intent
        is, and there’s no type for currency. toFixed(..)
        lets us specify how many decimal places we’d
        like the number rounded to, and it produces the
        string as necessary.
      </a>
    </pre>
    <script>

    </script>

  </div>
  </div>


  <div class="padre">
  <div class="hijo">
    <h4>Variables Constantes</h4>
    The newest version of JavaScript at the time of this writing (commonly
    called “ES6”) includes a new way to declare constants, by
    using const instead of var:
    <pre>
      const TAX_RATE = 0.08;
      var amount = 99.99;
      <a href="">Constants are useful just like variables with unchanged values,
      except that constants also prevent accidentally changing value somewhere
      else after the initial setting. If you tried to assign any different
      value to TAX_RATE after that first declaration, your program would
      reject the change (and in strict mode, fail with an error—see “Strict
      Mode” on page 45 in Chapter 2).</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>While vS Do While</h4>
    The only practical difference between these loops is whether the
    conditional is tested before the first iteration (while) or after the
    first iteration (do..while).
    <pre>
      while (numOfCustomers > 0) {
      console.log( "How may I help you?" );

      <a href="">// help the customer...</a>

      numOfCustomers = numOfCustomers - 1;
      }

      <a href="">// versus:</a>

      do {
      console.log( "How may I help you?" );

      <a href="">// help the customer...</a>

      numOfCustomers = numOfCustomers - 1;
      } while (numOfCustomers > 0);
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Scope</h4>
    scope (technically called
    lexical scope). In JavaScript, each function gets its own scope. Scope
    is basically a collection of variables as well as the rules for how those
    variables are accessed by name. Only code inside that function can
    access that function’s scoped variables.
    <pre>
      function one() {
      <a href="">// this `a` only belongs to the `one()` function</a>
      var a = 1;
      console.log( a );
      }

      function two() {
      <a href="">// this `a` only belongs to the `two()` function</a>
      var a = 2;
      console.log( a );
      }
      <a href="">one(); // 1
   two(); // 2
      </a>
      Also, a scope can be nested
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Scoope 2</h4>
    If one scope is nested inside another, code inside the innermost scope
    can access variables from either scope.
    <pre>
      function outer() {
        var a = 1;

        function inner() {
          var b = 2;
          <a href="">// we can access both `a` and `b` here</a>
            console.log( a + b ); <a href="">// 3</a>
        }

        inner();

        <a href="">// we can only access `a` here</a>
        console.log( a ); <a href="">// 1</a>
      }
      outer();

      <a href="">//Lexical scope rules say that code in one scope can access variables of
        either that scope or any scope outside of it.
        So, code inside the inner() function has access to both variables a
        and b, but code only in outer() has access only to a—it cannot
        access b because that variable is only inside inner()</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Evento addEventListener</h4>
    Attach a click event to the document.
    When the user clicks anywhere in the document, output "Hello World" in a <p> element with id="demo":
    <pre>

      < p id="demo"> /p>

        < script >
        document.addEventListener("click", function(){
            document.getElementById("demo").innerHTML = "Hello World!";
        });
        < /script >
        <a href="">//Da un click en cualquier lugar!</a>
        <a href="">//El evento keydown es lanzado cuando una tecla es presionada
          y produce un caracter</a>
          <a href="">//El evento transitionend es lanzado cuando una transición CSS se ha completado.</a>
    </pre>
    <p id="demo"></p>
    <script>
    document.addEventListener("click", function(){
    document.getElementById("demo").innerHTML = "Hello World!";
    });
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Evento document.querySelector()</h4>
    Get the first element in the document with class="example":
    <pre>
      < h2 class="example">A heading with class="example"< /h2>
      < p class="example">A paragraph with class="example".< /p>

      < button onclick="myFunction()">Try it< /button>

      < script>
      function myFunction() {
          document.querySelector(".example").style.backgroundColor = "red";
      }
      < /script>

    </pre>
    <h2 class="example">A heading with class="example"</h2>
    <p class="example">A paragraph with class="example".</p>
    <button onclick="myFunction()">Try it</button>
    <script>
    function myFunction() {
    document.querySelector(".example").style.backgroundColor = "red";
    }
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>.classList.add("");</h4>
    Add the "mystyle" class to a < div> element:
    <pre>
      < style>
      .mystyle {
        width: 300px;
        height: 50px;
        background-color: coral;
        color: white;
        font-size: 25px;
      }
      < /style>

      < button onclick="myFunction()">Try it< /button>

      < div id="myDIV">I am a DIV element < /div>
      < script>
      function myFunction() {
          document.getElementById("myDIV").classList.add("mystyle"); <a href="">agrega una
            clase css a el elemento myDiv</a>
      }
      < /script>
    </pre>
    <style>
    .mystyle {
        width: 300px;
        height: 50px;
        background-color: coral;
        color: white;
        font-size: 25px;
    }
    </style>
    <button onclick="myFunction2()">Try it</button>
    <div id="myDIV">I am a DIV element </div>
    <script>

    function myFunction2() {
    document.getElementById("myDIV").classList.add("mystyle");
    }
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Funcion Flecha</h4>
    Las funciones flecha son una de las novedades ES6 (ECMAScript 2015) que más pueden
    desconcertar a los desarrolladores tradicionales.
    <pre>
        <a href="">//Sintaxis ( param1, param2, ...rest ) => { expression; }</a>
        var add = ( x, y ) => x + y;
        console.info( add( 2, 4 ) ); <a href="">// 6</a>
        console.info( add( 4, 4 ) ); <a href="">// 8</a>
        console.info( add( 1, 2 ) ); <a href="">// 3</a>

        <a href="">//Es igual a </a>

        function add ( a, b ) {
          return a + b;
        }

        <a href="">//Si solo tenemos un parámetro, podemos obviar el paréntesis:</a>

        var double = x => x * 2;

        console.info( double( 2 ) ); <a href="">// 4</a>
        console.info( double( 5 ) ); <a href="">// 10</a>

        <a href="">//Si no necesitamos parámetros, tenemos que incluir el paréntesis vacío:</a>

        var hi = () => 'Hello World';

        console.info( hi() ); // Hello World

        <a href="">//Si necesitamos incluir varias instrucciones en nuestra función,
          entonces necesitamos incluir las clásicas llaves y el retorno:</a>

      var foo = ( param1, param2 ) => {
      var result;

    <a href="">// Do amazings things here...</a>

      return result;
    };
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>DOM</h4>
    El Modelo de Objetos del Documento (DOM) es una interfaz de programación de aplicaciones (API)
    para documentos HTML y XML. Define la estructura lógica de los documentos y el modo en
    que se accede y manipula un documento. En la especificación del DOM, el término "documento"
    se utiliza en un sentido amplio. XML se utiliza cada vez más como un medio para representar
    muchas clases diferentes de información que puede ser almacenada en sistemas diversos,
    y mucha de esta información se vería, en términos tradicionales, más como datos que
    como documentos. Sin embargo, XML presenta estos datos como documentos, y se puede usar
    el DOM para manipular estos datos.

    Con el Modelo de Objetos del Documento los programadores pueden construir documentos, navegar
    por su estructura, y añadir, modificar o eliminar elementos y contenido. Se puede acceder a
    cualquier cosa que se encuentre en un documento HTML o XML, y se puede modificar, eliminar o
    añadir usando el Modelo de Objetos del Documento, salvo algunas excepciones. En particular,
    aún no se han especificado las interfaces DOM para los subconjuntos internos y externos de XML.
    <pre>
        < div id="div-subtitulo">< /div>

        <a href="">//crear elemento</a>
        var elemento = document.createElement("h2");

        <a href="">//crear nodo de texto</a>
        var contenido = document.createTextNode("Este es nuestro texto");

        <a href="">//añadir el nodo de texto al elemento</a>
        elemento.appendChild(contenido); <a href="">//meter texto al elemento</a>

        <a href="">//agregar atributos al elemento</a>
        elemento.setAtribute("aling", "center");

        <a href="">//Agregar elemento al documento //se agrega el elemento al div-subtitulo</a>
        document.getElementById("div-subtitulo").appendChild(elemento);


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Window setInterval()</h4>
    Alert "Hello" every 3 seconds (3000 milliseconds):
    <pre>
        setInterval(function(){ alert("Hello"); }, 3000);
        <a href="">//a a llamar la funcion cada 3000s</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Data-* Attributes</h4>
    Use the data-* attribute to embed custom data:
    <pre>
    < input type="range" name="nombre" data-sizing="px" data-name="javier" data-cool="yeah">

    console.log(input.dataset); <a href="">//trae en forma de arreglo los data-*</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prtotype.filter()</h4>
    El método filter() crea un nuevo array con todos los elementos
    que cumplan la condición implementada por la función dada
    <pre>

      var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

      const result = words.filter(word => word.length > 6);

      console.log(result);
      <a href="">// expected output: Array ["exuberant", "destruction", "present"]</a>

    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.map()</h4>
    El método map() crea un nuevo array con los resultados de la
    llamada a la función indicada aplicados a cada uno de sus elementos.
    <pre>

    var numbers = [1, 5, 10, 15];
    var doubles = numbers.map(function(x) {
       return x * 2;
    });
    <a href="">// doubles is now [2, 10, 20, 30]</a>
    <a href="">// numbers is still [1, 5, 10, 15]</a>

    var numbers = [1, 4, 9];
    var roots = numbers.map(Math.sqrt);
    <a href="">// roots is now [1, 2, 3]</a>
    <a href="">// numbers is still [1, 4, 9]</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.sort()</h4>
    El método sort() ordena los elementos de un array localmente y devuelve el array. La ordenación no es necesariamente estable. El modo de ordenación por defecto responde
    a la posición del valor del string de acuerdo a su valor
    <pre>
      var frutas = ['guindas', 'manzanas', 'bananas'];
      frutas.sort(); <a href="">// ['bananas', 'guindas', 'manzanas']</a>
      <a href="">//Ordena por ascii, Cherry < bananas por la C mayus</a>

      var puntos = [1, 10, 2, 21];
      puntos.sort(); // [1, 10, 2, 21]
      <a href="">// Tenga en cuenta que 10 viene antes que 2</a>

      <a href="">//Una funcion compare regresa -1 o 1 , regresa 0 si los elementos son iguales </a>
      function compare(a, b) {
      if (a es menor que b según criterio de ordenamiento) {
        return -1;
      }
      if (a es mayor que b según criterio de ordenamiento) {
        return 1;
      }
      // a debe ser igual b
      return 0;
      }

      var arr = [ 40, 1, 5, 200 ];
      function comparar ( a, b ){ return a - b; } <a href="">//a = -1 b = 1</a>
      arr.sort( comparar ); <a href=""> // [ 1, 5, 40, 200 ]</a>

      <a href="">//Lo mismo pero una función anónima normal:</a>

      var arr = [ 40, 1, 5, 200 ];
      arr.sort(function(a,b){return a - b;});  <a href="">// [ 1, 5, 40, 200 ]</a>

      <a href="">//Lo mismo pero usando funcion Flecha</a>
      var arr = [ 40, 1, 5, 200 ];
      arr.sort((a,b)=>a-b);  <a href="">// [ 1, 5, 40, 200 ]</a>

      <a href="">//Ordenando array inventores .year = fecha nacimiento</a>
      const ordered = inventors.sort(function(primer_a_comparar, segundo_a_comparar){

        if(primer_a_comparar.year > segundo_a_comparar.year){
          return 1;
        }else{
          return -1;
        }

      });


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.reduce()</h4>
    El método reduce() aplica una función a un acumulador y a cada valor de un array
    (de izquierda a derecha) para reducirlo a un único valor.
    <pre>

      valorAnterior
        <a href="">//El valor devuelto (retornado) en la llamada anterior de la función, o el
          valorInicial, si se proveyó. </a>

      ValorActual
        <a href="">//que está siendo procesado en el array.</a>

      indiceActual
        <a href="">//Índice del elemento actual que está siendo procesado en el array.</a>

        [0,1,2,3,4].reduce(function(valorAnterior, valorActual, indice, vector){
          return valorAnterior + valorActual;
        });

        <a href="">// Primera llamada</a>
        valorAnterior = 0, valorActual = 1, indice = 1

        <a href="">// Segunda llamada</a>
        valorAnterior = 1, valorActual = 2, indice = 2

        <a href="">// Tercera llamada</a>
        valorAnterior = 3, valorActual = 3, indice = 3

        <a href="">// Cuarta llamada</a>
        valorAnterior = 6, valorActual = 4, indice = 4


        <a href="">//Esto con el fin de remplazar a :</a>

        var total = 0;

        for(var i=0;i< array.length;i++)
          total += array[i].años

        <a href="">------------------</a>
        <a href="">//inventor = arreglo</a>
        <a href="">//total = donde se hara la suma de la edad de todos los inventores</a>
        <a href="">//.passed = fecha when difunto</a>
        <a href="">//.year = fecha nacimiento</a>
        const totalYears = inventors.reduce((total, inventor) => { <a href="">//total se inicializa aqui</a>
            return total + (inventor.passed - inventor.year); <a href="">//total es la variable que servira como suma</a>
        },0); <a href="">//el 0 es pera darle valor a total, total = 0</a>


        <a href="">---------------------------------------</a>
        <a href="">//Cuantos hay de cada objeto</a>
        const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

        const transportation = data.reduce(function(obj, item) {
          if (!obj[item]) {  <a href="">//if 777 //si el conteo de "carros" es 0 entra</a>
            obj[item] = 0; <a href="">//item = car o truck o van</a>
          }
          obj[item]++;
          return obj;
        }, {
          <a href="">//en vez de meter variables de conteo, usamos el if 777</a>
        });
        console.log(transportation);


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4></h4>
    <pre>

    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4></h4>
    <pre>

    </pre>
    <script>

    </script>

  </div>
  </div>
</body>
</html>
