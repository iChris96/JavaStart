<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" type="text/css" href="estilo.css" media="screen" />
  <link href="https://fonts.googleapis.com/css?family=Asap:400i|Gloria+Hallelujah" rel="stylesheet">
  <title>Document</title>
</head>
<body>

  <div class="padre">
  <div class="hijo">
    <h4>Values & Types</h4>
    As we asserted in Chapter 1, JavaScript has typed values, not typed
    variables. The following built-in types are available:
    • string
    • number
    • boolean
    • null and undefined
    • object
    • symbol (new to ES6)
    JavaScript provides a typeof operator that can examine a value and
    tell you what type it is:
    <pre>
      var a;
      typeof a; <a href="">  // "undefined"</a>
      a = "hello world";
      typeof a; <a href="">  //"string"</a>
      a = 42;
      typeof a; <a href="">  // "number"</a>
      a = true;
      typeof a; <a href="">  // "boolean"</a>
      a = null;
      typeof a; <a href="">  // "object"--weird, bug</a>
      a = undefined;
      typeof a; <a href="">  // "undefined"</a>
    </pre>
    <script>

    </script>

  </div>
  </div>


  <div class="padre">
  <div class="hijo">
    <h4>Funciones Basicas 0</h4>
    <pre>
      var nombre; <a>//Variable</a>
      nombre = prompt("ingresa tu nombre"); <a href="">//Abre pantalla emergente preguntando nombre</a>
      alert(nombre); <a href="">//Alerta</a>
      document.write(nombre); <a href="">//Escribe el nombre</a>
      console.log(nombre); <a href="">//Escribe en el terminal</a>
  </pre>
    <script>
      /*
      var nombre;
      nombre = prompt("Ingresa Nombre");
      alert(nombre);
      document.write(nombre);
      */
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Compound Assigment</h4>
    <pre>
      +=, -=, *=, and /=
      are compound operators that combine a math operation with assignment,
      as in a += 2 (same as a = a + 2).
   </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Coercion</h4>
    If you have a number but need to print it on the screen, you need to convert the value to a string, and in
    JavaScript this conversion is called “coercion.”
    <pre>
      var a = "42";
      var b = Number( a );
      console.log( a );   <a href="">// "42"</a>
      console.log( b );   <a href="">// 42 </a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Variables Basicas</h4>
    JavaScript uses the latter approach, dynamic typing, meaning variables
    can hold values of any type without any type enforcement.
    As mentioned earlier, we declare a variable using the var statement
    —notice there’s no other type information in the declaration. Consider
    this simple program:
    <pre>
      var amount = 99.99;
      amount = amount * 2;
      console.log( amount );  <a href="">// 199.98</a>
      <a href="">// convert `amount` to a string, and</a>
      <a href="">// add "$" on the beginning</a>
      amount = "$" + String( amount );
      console.log( amount ); <a href="">// "$199.98"</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Variables Basicas</h4>
    This is more typically called constants, when you declare a variable
    with a value and intend for that value to not change throughout the
    program.
    You declare these constants, often at the top of a program, so that it’s
    convenient for you to have one place to go to alter a value if you
    need to. By convention, JavaScript variables as constants are usually
    capitalized, with underscores _ between multiple words.
    <pre>
      var TAX_RATE = 0.08; <a href="">// 8% sales tax</a>
      var amount = 99.99;
      amount = amount * 2;
      amount = amount + (amount * TAX_RATE);
      console.log( amount ); <a href="">// 215.9784</a>
      console.log( amount.toFixed( 2 ) ); <a href="">// "215.98"</a>
      <a href="">
        Similar to how console.log(..) is a function log(..) accessed as an object property on the
        console value, toFixed(..) here is a function that can be accessed on number values.
        JavaScript numbers aren’t automatically formatted for dollars—
        the engine doesn’t know what your intent
        is, and there’s no type for currency. toFixed(..)
        lets us specify how many decimal places we’d
        like the number rounded to, and it produces the
        string as necessary.
      </a>
    </pre>
    <script>

    </script>

  </div>
  </div>


  <div class="padre">
  <div class="hijo">
    <h4>Variables Constantes</h4>
    The newest version of JavaScript at the time of this writing (commonly
    called “ES6”) includes a new way to declare constants, by
    using const instead of var:
    <pre>
      const TAX_RATE = 0.08;
      var amount = 99.99;
      <a href="">Constants are useful just like variables with unchanged values,
      except that constants also prevent accidentally changing value somewhere
      else after the initial setting. If you tried to assign any different
      value to TAX_RATE after that first declaration, your program would
      reject the change (and in strict mode, fail with an error—see “Strict
      Mode” on page 45 in Chapter 2).</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>While vS Do While</h4>
    The only practical difference between these loops is whether the
    conditional is tested before the first iteration (while) or after the
    first iteration (do..while).
    <pre>
      while (numOfCustomers > 0) {
      console.log( "How may I help you?" );

      <a href="">// help the customer...</a>

      numOfCustomers = numOfCustomers - 1;
      }

      <a href="">// versus:</a>

      do {
      console.log( "How may I help you?" );

      <a href="">// help the customer...</a>

      numOfCustomers = numOfCustomers - 1;
      } while (numOfCustomers > 0);
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Scope</h4>
    scope (technically called
    lexical scope). In JavaScript, each function gets its own scope. Scope
    is basically a collection of variables as well as the rules for how those
    variables are accessed by name. Only code inside that function can
    access that function’s scoped variables.
    <pre>
      function one() {
      <a href="">// this `a` only belongs to the `one()` function</a>
      var a = 1;
      console.log( a );
      }

      function two() {
      <a href="">// this `a` only belongs to the `two()` function</a>
      var a = 2;
      console.log( a );
      }
      <a href="">one(); // 1
   two(); // 2
      </a>
      Also, a scope can be nested
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Scoope 2</h4>
    If one scope is nested inside another, code inside the innermost scope
    can access variables from either scope.
    <pre>
      function outer() {
        var a = 1;

        function inner() {
          var b = 2;
          <a href="">// we can access both `a` and `b` here</a>
            console.log( a + b ); <a href="">// 3</a>
        }

        inner();

        <a href="">// we can only access `a` here</a>
        console.log( a ); <a href="">// 1</a>
      }
      outer();

      <a href="">//Lexical scope rules say that code in one scope can access variables of
        either that scope or any scope outside of it.
        So, code inside the inner() function has access to both variables a
        and b, but code only in outer() has access only to a—it cannot
        access b because that variable is only inside inner()</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Evento addEventListener</h4>
    Attach a click event to the document.
    When the user clicks anywhere in the document, output "Hello World" in a <p> element with id="demo":
    <pre>

      < p id="demo"> /p>

        < script >
        document.addEventListener("click", function(){
            document.getElementById("demo").innerHTML = "Hello World!";
        });
        < /script >
        <a href="">//Da un click en cualquier lugar!</a>
        <a href="">//El evento keydown es lanzado cuando una tecla es presionada
          y produce un caracter</a>
          <a href="">//El evento transitionend es lanzado cuando una transición CSS se ha completado.</a>
    </pre>
    <p id="demo"></p>
    <script>
    document.addEventListener("click", function(){
    document.getElementById("demo").innerHTML = "Hello World!";
    });
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Evento document.querySelector()</h4>
    Get the first element in the document with class="example":
    <pre>
      < h2 class="example">A heading with class="example"< /h2>
      < p class="example">A paragraph with class="example".< /p>

      < button onclick="myFunction()">Try it< /button>

      < script>
      function myFunction() {
          document.querySelector(".example").style.backgroundColor = "red";
      }
      < /script>

    </pre>
    <h2 class="example">A heading with class="example"</h2>
    <p class="example">A paragraph with class="example".</p>
    <button onclick="myFunction()">Try it</button>
    <script>
    function myFunction() {
    document.querySelector(".example").style.backgroundColor = "red";
    }
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>.classList.add("");</h4>
    Add the "mystyle" class to a < div> element:
    <pre>
      < style>
      .mystyle {
        width: 300px;
        height: 50px;
        background-color: coral;
        color: white;
        font-size: 25px;
      }
      < /style>

      < button onclick="myFunction()">Try it< /button>

      < div id="myDIV">I am a DIV element < /div>
      < script>
      function myFunction() {
          document.getElementById("myDIV").classList.add("mystyle"); <a href="">agrega una
            clase css a el elemento myDiv</a>
      }
      < /script>
    </pre>
    <style>
    .mystyle {
        width: 300px;
        height: 50px;
        background-color: coral;
        color: white;
        font-size: 25px;
    }
    </style>
    <button onclick="myFunction2()">Try it</button>
    <div id="myDIV">I am a DIV element </div>
    <script>

    function myFunction2() {
    document.getElementById("myDIV").classList.add("mystyle");
    }
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Funcion Flecha</h4>
    Las funciones flecha son una de las novedades ES6 (ECMAScript 2015) que más pueden
    desconcertar a los desarrolladores tradicionales.
    <pre>
        <a href="">//Sintaxis ( param1, param2, ...rest ) => { expression; }</a>
        var add = ( x, y ) => x + y;
        console.info( add( 2, 4 ) ); <a href="">// 6</a>
        console.info( add( 4, 4 ) ); <a href="">// 8</a>
        console.info( add( 1, 2 ) ); <a href="">// 3</a>

        <a href="">//Es igual a </a>

        function add ( a, b ) {
          return a + b;
        }

        <a href="">//Si solo tenemos un parámetro, podemos obviar el paréntesis:</a>

        var double = x => x * 2;

        console.info( double( 2 ) ); <a href="">// 4</a>
        console.info( double( 5 ) ); <a href="">// 10</a>

        <a href="">//Si no necesitamos parámetros, tenemos que incluir el paréntesis vacío:</a>

        var hi = () => 'Hello World';

        console.info( hi() ); // Hello World

        <a href="">//Si necesitamos incluir varias instrucciones en nuestra función,
          entonces necesitamos incluir las clásicas llaves y el retorno:</a>

      var foo = ( param1, param2 ) => {
      var result;

    <a href="">// Do amazings things here...</a>

      return result;
    };
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>DOM</h4>
    El Modelo de Objetos del Documento (DOM) es una interfaz de programación de aplicaciones (API)
    para documentos HTML y XML. Define la estructura lógica de los documentos y el modo en
    que se accede y manipula un documento. En la especificación del DOM, el término "documento"
    se utiliza en un sentido amplio. XML se utiliza cada vez más como un medio para representar
    muchas clases diferentes de información que puede ser almacenada en sistemas diversos,
    y mucha de esta información se vería, en términos tradicionales, más como datos que
    como documentos. Sin embargo, XML presenta estos datos como documentos, y se puede usar
    el DOM para manipular estos datos.

    Con el Modelo de Objetos del Documento los programadores pueden construir documentos, navegar
    por su estructura, y añadir, modificar o eliminar elementos y contenido. Se puede acceder a
    cualquier cosa que se encuentre en un documento HTML o XML, y se puede modificar, eliminar o
    añadir usando el Modelo de Objetos del Documento, salvo algunas excepciones. En particular,
    aún no se han especificado las interfaces DOM para los subconjuntos internos y externos de XML.
    <pre>
        < div id="div-subtitulo">< /div>

        <a href="">//crear elemento</a>
        var elemento = document.createElement("h2");

        <a href="">//crear nodo de texto</a>
        var contenido = document.createTextNode("Este es nuestro texto");

        <a href="">//añadir el nodo de texto al elemento</a>
        elemento.appendChild(contenido); <a href="">//meter texto al elemento</a>

        <a href="">//agregar atributos al elemento</a>
        elemento.setAtribute("aling", "center");

        <a href="">//Agregar elemento al documento //se agrega el elemento al div-subtitulo</a>
        document.getElementById("div-subtitulo").appendChild(elemento);


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Window setInterval()</h4>
    Alert "Hello" every 3 seconds (3000 milliseconds):
    <pre>
        setInterval(function(){ alert("Hello"); }, 3000);
        <a href="">//a a llamar la funcion cada 3000s</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Data-* Attributes</h4>
    Use the data-* attribute to embed custom data:
    <pre>
    < input type="range" name="nombre" data-sizing="px" data-name="javier" data-cool="yeah">

    console.log(input.dataset); <a href="">//trae en forma de arreglo los data-*</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prtotype.filter()</h4>
    El método filter() crea un nuevo array con todos los elementos
    que cumplan la condición implementada por la función dada
    <pre>

      var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

      const result = words.filter(word => word.length > 6);

      console.log(result);
      <a href="">// expected output: Array ["exuberant", "destruction", "present"]</a>

    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.map()</h4>
    El método map() crea un nuevo array con los resultados de la
    llamada a la función indicada aplicados a cada uno de sus elementos.
    <pre>

    var numbers = [1, 5, 10, 15];
    var doubles = numbers.map(function(x) {
       return x * 2;
    });
    <a href="">// doubles is now [2, 10, 20, 30]</a>
    <a href="">// numbers is still [1, 5, 10, 15]</a>

    var numbers = [1, 4, 9];
    var roots = numbers.map(Math.sqrt);
    <a href="">// roots is now [1, 2, 3]</a>
    <a href="">// numbers is still [1, 4, 9]</a>
    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.sort()</h4>
    El método sort() ordena los elementos de un array localmente y devuelve el array. La ordenación no es necesariamente estable. El modo de ordenación por defecto responde
    a la posición del valor del string de acuerdo a su valor
    <pre>
      var frutas = ['guindas', 'manzanas', 'bananas'];
      frutas.sort(); <a href="">// ['bananas', 'guindas', 'manzanas']</a>
      <a href="">//Ordena por ascii, Cherry < bananas por la C mayus</a>

      var puntos = [1, 10, 2, 21];
      puntos.sort(); // [1, 10, 2, 21]
      <a href="">// Tenga en cuenta que 10 viene antes que 2</a>

      <a href="">//Una funcion compare regresa -1 o 1 , regresa 0 si los elementos son iguales </a>
      function compare(a, b) {
      if (a es menor que b según criterio de ordenamiento) {
        return -1;
      }
      if (a es mayor que b según criterio de ordenamiento) {
        return 1;
      }
      // a debe ser igual b
      return 0;
      }

      var arr = [ 40, 1, 5, 200 ];
      function comparar ( a, b ){ return a - b; } <a href="">//a = -1 b = 1</a>
      arr.sort( comparar ); <a href=""> // [ 1, 5, 40, 200 ]</a>

      <a href="">//Lo mismo pero una función anónima normal:</a>

      var arr = [ 40, 1, 5, 200 ];
      arr.sort(function(a,b){return a - b;});  <a href="">// [ 1, 5, 40, 200 ]</a>

      <a href="">//Lo mismo pero usando funcion Flecha</a>
      var arr = [ 40, 1, 5, 200 ];
      arr.sort((a,b)=>a-b);  <a href="">// [ 1, 5, 40, 200 ]</a>

      <a href="">//Ordenando array inventores .year = fecha nacimiento</a>
      const ordered = inventors.sort(function(primer_a_comparar, segundo_a_comparar){

        if(primer_a_comparar.year > segundo_a_comparar.year){
          return 1;
        }else{
          return -1;
        }

      });


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Array.prototype.reduce()</h4>
    El método reduce() aplica una función a un acumulador y a cada valor de un array
    (de izquierda a derecha) para reducirlo a un único valor.
    <pre>

      valorAnterior
        <a href="">//El valor devuelto (retornado) en la llamada anterior de la función, o el
          valorInicial, si se proveyó. </a>

      ValorActual
        <a href="">//que está siendo procesado en el array.</a>

      indiceActual
        <a href="">//Índice del elemento actual que está siendo procesado en el array.</a>

        [0,1,2,3,4].reduce(function(valorAnterior, valorActual, indice, vector){
          return valorAnterior + valorActual;
        });

        <a href="">// Primera llamada</a>
        valorAnterior = 0, valorActual = 1, indice = 1

        <a href="">// Segunda llamada</a>
        valorAnterior = 1, valorActual = 2, indice = 2

        <a href="">// Tercera llamada</a>
        valorAnterior = 3, valorActual = 3, indice = 3

        <a href="">// Cuarta llamada</a>
        valorAnterior = 6, valorActual = 4, indice = 4


        <a href="">//Esto con el fin de remplazar a :</a>

        var total = 0;

        for(var i=0;i< array.length;i++)
          total += array[i].años

        <a href="">------------------</a>
        <a href="">//inventor = arreglo</a>
        <a href="">//total = donde se hara la suma de la edad de todos los inventores</a>
        <a href="">//.passed = fecha when difunto</a>
        <a href="">//.year = fecha nacimiento</a>
        const totalYears = inventors.reduce((total, inventor) => { <a href="">//total se inicializa aqui</a>
            return total + (inventor.passed - inventor.year); <a href="">//total es la variable que servira como suma</a>
        },0); <a href="">//el 0 es pera darle valor a total, total = 0</a>


        <a href="">---------------------------------------</a>
        <a href="">//Cuantos hay de cada objeto</a>
        const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

        const transportation = data.reduce(function(obj, item) {
          if (!obj[item]) {  <a href="">//if 777 //si el conteo de "carros" es 0 entra</a>
            obj[item] = 0; <a href="">//item = car o truck o van</a>
          }
          obj[item]++;
          return obj;
        }, {
          <a href="">//en vez de meter variables de conteo, usamos el if 777</a>
        });
        console.log(transportation);


    </pre>
    <script>

    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Objets</h4>
    The object type refers to a compound value where you can set properties (named locations) that each hold their own values of any type.
    This is perhaps one of the most useful value types in all of JavaScript.
    <pre>
      var obj = {
    	a: "hello world",
        c: true,
       'hola jeje!': 50
    };


    //dot notation
    obj.a;		<a href="">// "hello world"</a>
    obj.b;		<a href="">// 42</a>
    obj.c;		<a href="">// true</a>

    //bracket notation
    obj["a"];	<a href="">// "hello world"</a>
    obj["b"];	<a href="">// 42</a>
    obj["c"];	<a href="">// true</a>
    obj["hola jeje!"]; <a href="">//llamar objetos de esta manera es util cuando hay variables como hola jeje!</a>
    </pre>
    <script>
    var obj = {
    	a: "hello world",
    	b: 42,
    	c: true,
      'hola jeje!': 50
    };

    obj.a;		// "hello world"
    obj.b;		// 42
    obj.c;		// true

    obj["a"];	// "hello world"
    obj["b"];	// 42
    obj["c"];	// true
    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
    <h4>Objets2</h4>
    Of course, bracket notation is also useful if you want to access a
    property/key but the name is stored in another variable, such as:
    <pre>
      var obj = {
    	a: "hello world",
    	b: 42
      };

      var b = "a"; <a href="">//guarda el valor de la variable a del obj </a>

      obj[b];	<a href="">//"hello world"</a>
      obj["b"];   <a href="">//42</a>
      obj.b;  <a href="">//42</a>
      obj.a;  <a href="">//"hello world"</a>
      obj[a];  <a href="">//error   </a>
    </pre>
    <script>
    var obj2 = {
      aa: "hello",
      bb:  42
    }

    var bb = "aa";


    </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Arrays</h4>
  An array is an object that holds values (of any type) not particularly in
  named properties/keys, but rather in numerically indexed positions. For example:
  <pre>
    var arr = [
  	"hello world",
  	42,
  	true
    ];

  arr[0];			<a href="">// "hello world"</a>
  arr[1];			<a href="">// 42</a>
  arr[2];			<a href="">// true</a>
  arr.length;		<a href="">// 3</a>

  typeof arr;		<a href="">// "object"</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Truthy & Falsy</h4>
  <pre>
    The specific list of "falsy" values in JavaScript is as follows:

    <a href="">"" (empty string)
      0, -0, NaN (invalid number)
      null, undefined
      false</a>


    Any value that's not on this "falsy" list is "truthy." Here are some examples of those:

    <a href="">  "hello"
      42
      true
      [ ], [ 1, "2", 3 ] (arrays)
      { }, { a: 42 } (objects)
      function foo() { .. } (functions)</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Equality</h4>
  <pre>
  The difference between == and === is usually characterized that == checks for value equality
  and === checks for both value and type equality. However, this is inaccurate.

  == usa Coercion
  === no usa coercion

  var a = "42";
  var b = 42;

  a == b;			<a href="">// true</a>
  a === b;		<a href="">// false</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Hoisting</h4>
  Wherever a var appears inside a scope, that declaration is taken to
  belong to the entire scope and accessible everywhere throughout.

  Metaphorically, this behavior is called hoisting, when a var declaration is
  conceptually "moved" to the top of its enclosing scope. Technically, this
  process is more accurately explained by how code is compiled, but we
  can skip over those details for now.
  <pre>
  var a = 2;

  foo();				<a href="">  // works because `foo()`</a>
  						<a href="">// declaration is "hoisted"</a>

  function foo() {
  	a = 3;

  	console.log( a );	<a href="">// 3</a>

  	var a;			<a href="">  // declaration is "hoisted"</a>
  					<a href="">  // to the top of `foo()`</a>
  }

  console.log( a ); <a href="">//2</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Nested Scopes</h4>
  When you declare a variable, it is available
  anywhere in that scope, as well as any lower/inner scopes. For example:
  <pre>
    function foo() {
  	var a = 1;

  	function bar() {
  		var b = 2;

  		function baz() {
  			var c = 3;

  			console.log( a, b, c );	<a href="">// 1 2 3 <<<< primero en ejecutarse</a>
  		}

  		baz();
  		console.log( a, b );		<a href="">// 1 2</a>
      <a href="">     //console.log( a, b, c );    error</a>
  	}

  	bar();
  	console.log( a );			<a href="">  // 1 <<<< ultimo en ejecutarse </a>
  }

  foo();

  <a href="">//Notice that c is not available inside of bar(), because it's declared only inside
    the inner baz() scope, and that b is not available to foo() for the same reason.

    If you try to access a variable's value in a scope where it's not available,
    you'll get a ReferenceError thrown.</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Strict Mode</h4>
  ES5 added a "strict mode" to the language, which tightens the rules for certain behaviors.
  Generally, these restrictions are seen as keeping the code to a safer and
  more appropriate set of guidelines. Also, adhering to strict mode makes your code
  generally more optimizable
  by the engine. Strict mode is a big win for code, and you should use it for all your programs.
  <pre>
    function foo() {
  	"use strict";

  	<a href="">// this code is strict mode</a>

  	function bar() {
  		<a href="">// this code is strict mode</a>
  	}
  }

  <a href="">// this code is not strict mode</a>

  <a href="">----------------------------------------------------------------</a>

  Compare that to:

    "use strict";

    function foo() {
    	<a href="">// this code is strict mode</a>

    	function bar() {
    		<a href="">// this code is strict mode</a>
    	}
    }

  <a href="">  // this code is strict mode</a>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Closure</h4>
  Puede pensar en el closure como una forma de "recordar" y continuar accediendo al alcance
  de una función (sus variables) incluso una vez que la función haya terminado de ejecutarse.
  <pre>
    function makeAdder(x) {
  	<a href="">// parameter `x` is an inner variable
      // inner function `add()` uses `x`, so
      // it has a "closure" over it</a>
  	function add(y) {
  		return y + x;
  	};

  	return add;
  }
  <a href="">The reference to the inner add(..) function that gets returned with each call
    to the outer makeAdder(..) is able
    to remember whatever x value was passed in to makeAdder(..). Now, let's use makeAdder(..):</a>


  var plusOne = makeAdder( 1 ); <a href="">//x = 1</a>

  var plusTen = makeAdder( 10 ); <a href="">//x = 10</a>

  plusOne( 3 );		// 4  < -- 1 + 3
  plusOne( 41 );		// 42 < -- 1 + 41

  plusTen( 13 );		// 23 < -- 10 + 13

  <a href="">//When we call makeAdder(1), we get back a reference to its inner add(..)
    that remembers x as 1. We call this function reference plusOne(..).

    When we call makeAdder(10), we get back another reference to its inner add(..) that
    remembers x as 10. We call this function reference plusTen(..).

    When we call plusOne(3), it adds 3 (its inner y) to the 1 (remembered by x),
    and we get 4 as the result.

    When we call plusTen(13), it adds 13 (its inner y) to the 10 (remembered by x),
    and we get 23 as the result.</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Modules</h4>
  El uso más común de cierre en JavaScript es el patrón del módulo. Los módulos
  le permiten definir detalles privados de implementación (variables, funciones)
  que están ocultos del mundo
  exterior, así como una API pública a la que se puede acceder desde el exterior.
  <pre>
    <a href="">//The User() function serves as an outer scope that holds the variables
      username and password, as well as the inner doLogin() function; these are all private
      inner details of this User module that cannot be accessed from the outside world.</a>
    function User(){
  	var username, password;

  	function doLogin(user,pw) {
  		username = user; <a href="">//The inner doLogin() function has a closure over
                                username and password, meaning it will
                                retain its access to them even after the User() function
                                finishes running.</a>
  		password = pw;

    		<a href="">// do the rest of the login work</a>
    	}

    	var publicAPI = {
    		login: doLogin
    	};

    	return publicAPI;
    }

    <a href="">// create a `User` module instance</a>
    var fred = User(); <a href="">//Executing User() creates an instance of the User module -- a
      whole new scope is created, and thus a whole new copy of each of these inner
      variables/functions. We assign this instance to fred.
      If we run User() again, we'd get a new instance entirely separate from fred.</a>

    fred.login( "fred", "12Battery34!" );
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>this</h4>
  If a function has a this reference inside it, that this
  reference usually points to an object. But which object it points to depends
  on how the function was called.

  It's important to realize that this does not refer to the function itself, as
  is the most common misconception.
  <pre>
    function foo() {
  	console.log( this.bar );
  }

  var bar = "global";

  var obj1 = {
  	bar: "obj1",
  	foo: foo
  };

  var obj2 = {
  	bar: "obj2"
  };

  // --------

  foo();				<a href="">// "global"</a>
  obj1.foo();			<a href="">// "obj1"</a>
  foo.call( obj2 );		<a href="">// "obj2"</a>
  new foo();			<a href="">// undefined</a>

  <a href="">foo() ends up setting this to the global object in non-strict mode --
    in strict mode, this would be undefined and you'd get an error in accessing
    the bar property -- so "global" is the value found for this.bar.

    obj1.foo() sets this to the obj1 object.

    foo.call(obj2) sets this to the obj2 object.

    new foo() sets this to a brand new empty object.</a>

    <a href="">//La palabra clave this está vinculada dinámicamente en función de cómo
      se ejecuta la función en cuestión, y resulta que hay cuatro reglas
      simples para comprender y determinar completamente este enlace.</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Prototypes</h4>
  Cuando hace referencia a una propiedad en un objeto, si esa propiedad no existe,
  JavaScript usará automáticamente la referencia del prototipo interno de ese
  objeto para buscar otro objeto para buscar la propiedad. Podrías pensar
  en esto casi como una alternativa si falta la propiedad.
  <pre>
    var foo = {
  	a: 42
  };

  <a href="">// create `bar` and link it to `foo`</a>
  var bar = Object.create( foo );

  bar.b = "hello world";

  bar.b;		<a href="">// "hello world"</a>
  bar.a;		<a href="">// 42 < -- delegated to `foo`</a>

  <a href="">//bar al no encontrar la propiedad .a en la variable bar, entonces como estaba linkeada
    a foo con object.create(); entonces buscara la propiedad en foo</a>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>IIFE immediately invoked function expression</h4>
  La primera razón para usar una IIFE es por la privacidad de los datos.
  Las variables declaradas con var en Javascript tienen un alcance a nivel de
  función (solo se pueden usar en la función que las contiene).

  Por esa razón toda variable declarada dentro de una IIFE no puede ser usada
  por fuera.
  <pre>
  <a href="">Primera explesion</a>

  (function () {
    var foo = "ABC";

    <a href="">// Esto imprime "ABC"</a>
    console.log(foo);
  })();  <a href="">//<<<<< iife</a>

  <a href="">// ReferenceError: foo is not defined</a>
  console.log(foo);

  <a href="">---------------------------------------
    segunda expression</a>

  function miFuncionInmediata () {
    var foo = "ABC";

  <a href="">  // Esto imprime "ABC"</a>
    console.log(foo);
  }

  miFuncionInmediata();

  <a href="">// ReferenceError: foo is not defined</a>
  console.log(foo);

  <a href="">//La primera y segunda expresion tienen los mismos resultados pero...

    ¿Entonces por qué nos encontramos a menudo con la primera expresión?

    1-Primero porque estamos asignando un nombre a la función, cuando realmente no
    se necesita. Estamos ocupando el global namespace,
    incrementando la posibilidad de que ocurra alguna colisión entre
    identificadores.

    2- Segundo, el último ejemplo no nos dice que se trata de una IIFE por sí
    mismo. A diferencia del caso anterior, en donde basta ver el código para
    saber que se trata de una función anónima que solo necesita ser invocada
    una vez, inmediatamente luego de su creación.

    3- Dado que la función tiene un nombre, ésta podría ser usada por
    equivocación más de una vez.

    ----------------------------------------------------------------
    Debes tener en cuenta que se pueden pasar parámetros a una IIFE:
    </a>

        var variableExterna = "ABC";

        (function (variableInterna) {
            <a href="">// Esto imprime "ABC"</a>
            console.log(variableInterna);
        })(variableExterna);

        <a href="">Esta es la historia detrás de las IIFEs (Immediately Invoked Function
          Expressions).

          Esta forma de usar las funciones se usa muy amenudo en patrones y
          bibliotecas de Javascript</a>



  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Clouseres 2</h4>
  <pre>
    function greet(){
    var greeting = "Hi";
    function greetMe(name){
    	console.log(`${greeting} ${name}`);
    }
    return greetMe;
  }

  var greet1 = greet();
  greet1("Miguel");

  <a href="">Ejecutamos la función greet, Se crea un nuevo contexto de ejecución, se guarda
     espació en memoria para la variable greeting y la función greetMe.

    La función interna greetMe se devuelve con la palabra clave return, digo
    devuelve por que NO SE EJECUTA. Únicamente estamos devolviendo la función.

    No se crea ningún contexto de ejecución puesto que no ejecutamos la función.
    Únicamente guardamos la referencia de la función en la variable greet1

    Ejecutamos la función greet1. Empieza a ejecutar el cuerpo de está función

    El motor de JavaScript, V8, creó un contexto de ejecución al llamar a la
    función greet. Cuando el cuerpo de la función terminó de ser ejecutado este
    contexto de ejecución fue desechado. No pasó lo mismo con la variable
    greeting, esta variable sigue estando en memoria. Por lo que al ejecutar
    la función interna greetMe

    Finalmente el motor de JavaScript encuentra la referencia de greeting y
    obtiene su valor. Se ejecuta el console.log y nos muestra: Hi Miguel.</a>

  ---------------------------------------

  function Dog (age, name){
  var age;
  var name;

  return {
  	greet: function() {
    	console.log(`My name is ${name}, I am ${age}`);
    }
  }
}

  var nasus = Dog(420, "Nasus");
  nasus.greet();

  <a href="">//Los closures tienen una similitud con  las clases de la programación
    orientada a objetos. Tenemos una clase que tiene propiedades
     y métodos. Los métodos pueden acceder a las propiedades definidas
     fuera de los mismos.</a>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Hoisting 2</h4>
  Comportamiento por defecto de subir declaraciones al inicio de cada scope
  <pre>
    (function(){
      'use strict';

      var result = 0; <a href="">//global dentro de scope</a>

      var sum = function(n1,n2){
        console.log(result);  <a href="">//0</a>
        result = n1 + n2; <a href="">//result global</a>

        return result;
      };

      sum(2, 2);
      console.log(result); <a href="">//4</a>

    })();

    <a href="">---------------------------------------</a>
    (function(){
      'use strict';

      var result = 0; <a href="">//global dentro de scope</a>

      var sum = function(n1,n2){
        console.log(result);  <a href="">//undefined</a>
        <a href="">var</a> result = n1 + n2;      <a href="">//que pasa si se hace result local dentro de sum?</a>

        return result;
      };

      sum(2, 2);
      console.log(result); <a href="">//0</a>

    })();

    <a href="">---------------------------------------</a>
    <a href="">Lo que interpreto javascript fue aplicando hosting esto...</a>
    <a href="">//que por cierto es la manera correcta de declarar las cosas</a>

    (function(){
      'use strict';

    <a href="">  var result;
      result = 0;</a>

      var sum = function(n1,n2){
        var result; <a href="">//subio la declaracion al inicio por si solo</a>
        console.log(result); <a href="">//undefined</a>

        result = n1 + n2;
        return result;
      };

      sum(2, 2);
      console.log(result); <a href="">//0</a>

    })();

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4>Callbacks</h4>
  Son funcionesx dentro de otra funcion1 que van a ser llamadas, pero sin
  especificar a la funcion1 cual de funcionx le llegara como parametro
  <pre>
      funcion suma(n1,n2){
        return suma n1 + n2;
      }

      funcion uno (name,callback){ <a href="">//le puedes pasar cualquier otra funcion x</a>
        console.log("eres +" name "y tu suma es: " callback(5,3));
      }

      uno(juan,suma);
      <a href="">//uno(pepe,resta);</a>
  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

  <div class="padre">
  <div class="hijo">
  <h4></h4>

  <pre>

  </pre>
  <script>

  </script>

  </div>
  </div>

</body>
</html>
